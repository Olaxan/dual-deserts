#pragma kernel CSGenerator

#include "/Includes/Volume.cginc"
#include "/Includes/Tables.cginc"
#include "/Includes/Simplex.cginc"

//#define CLOSE_FIELD

static uint2 oa[3] = 
{
	uint2(1,2),
	uint2(0,2),
	uint2(0,1)
};

int3 chunkOffset;

float3 noiseOffset;
float3 noiseScale;

float derivativeStep;

float surfaceLevel;
float surfaceScale;
float surfaceMagnitude;
float surfaceDistanceMult;

float caveScale;
float caveDistanceMult;

float density(in float3 p)
{
	float depth = p.y - surfaceLevel;

	float surf = depth;
	surf += snoise(p.xz * surfaceScale) * surfaceMagnitude;
	surf += snoise(p.xz * surfaceScale / 5) * surfaceMagnitude * 3;
	surf *= surfaceDistanceMult;

	float caves = snoise(p * caveScale);
	caves *= saturate(depth / 100);
	caves *= 0;
	caves *= caveDistanceMult;

	return max(surf, caves);
}

float3 estimateNormal(float3 p) {
	return normalize(float3(
		density(float3(p.x + derivativeStep, p.y, p.z)) - density(float3(p.x - derivativeStep, p.y, p.z)),
		density(float3(p.x, p.y + derivativeStep, p.z)) - density(float3(p.x, p.y - derivativeStep, p.z)),
		density(float3(p.x, p.y, p.z + derivativeStep)) - density(float3(p.x, p.y, p.z - derivativeStep))
	));
}

// for function f(p)
float3 calculateNormal(in float3 p)
{
	const float h = derivativeStep; // 0.0001
	const float2 k = float2(1, -1);
	return normalize(
		k.xyy * density(p + k.xyy * h) +
		k.yyx * density(p + k.yyx * h) +
		k.yxy * density(p + k.yxy * h) +
		k.xxx * density(p + k.xxx * h));
}

[numthreads(8,8,1)]
void CSGenerator(uint3 id : SV_DispatchThreadID)
{
	int index = getVolumeIndex(id);
	int3 pos = int3(id) + chunkOffset * (int3(isoSize) - int3(2, 2, 2));
	float3 noisePos = (float3(pos) + noiseOffset) * noiseScale;

	IsoPoint p;

	p.dist = density(noisePos);
	p.normal = estimateNormal(noisePos);

	#ifdef CLOSE_FIELD
	if (p.dist <= 0)
	{
		if (id.x == 0)
		{
			p.dist = 0.5;
			p.normal = -axes[0];
		}
		else if (id.y == 0)
		{
			p.dist = 0.5;
			p.normal = -axes[1];
		}
		else if (id.z == 0)
		{
			p.dist = 0.5;
			p.normal = -axes[2];
		}
		else if (id.x == isoSize.x - 2)
		{
			p.dist = 0.5;
			p.normal = axes[0];
		}
		else if (id.y == isoSize.y - 2)
		{
			p.dist = 0.5;
			p.normal = axes[1];
		}
		else if (id.z == isoSize.z - 2)
		{
			p.dist = 0.5;
			p.normal = axes[2];
		}
	}
	#endif

	//p.dist = float(id.y) - floorLevel;
	//p.normal = float3(0, sign(p.dist), 0);

	iso[index] = p;
}
