#pragma kernel CSGenerator
#pragma kernel CSSurfaceGenerator

#include "/Includes/Volume.cginc"
#include "/Includes/Tables.cginc"
#include "/Includes/Simplex.cginc"
#include "/Includes/Functions.cginc"

//#define CLOSE_FIELD


int3 chunkOffset;

float3 noiseOffset;
float3 noiseScale;

float derivativeStep;

float surfaceLevel;
float surfaceScale;
float surfaceMagnitude;

float warpScale;
float warpMagnitude;

uint lodSize;
uint lodChunksPerAxis;
uint lodRes;

float4x4 octaveMat0;
float4x4 octaveMat1;
float4x4 octaveMat2;
float4x4 octaveMat3;


float3 rot(float3 coord, float4x4 mat)
{
	return float3(dot(mat._11_12_13, coord),	// 3x3 transform,
				  dot(mat._21_22_23, coord),	// no translation
				  dot(mat._31_32_33, coord));
}

float usnoise(in float2 p)
{
	return (1.0 + snoise(p)) / 2.0;
}

float usnoise(in float3 p)
{
	return (1.0 + snoise(p)) / 2.0;
}

float3 snoise3(in float3 v)
{
	return float3 (
		snoise(v),
		snoise(v + 17.0),
		snoise(v - 43.0)
	);
}

float surface(in float3 p)
{
	float surf = surfaceLevel - p.y;

	float3 warp = snoise3(p * warpScale);
	float3 wp = p + warp * warpMagnitude;

	float3 c0 = rot(wp, octaveMat0);
	float3 c1 = rot(wp, octaveMat1);
	float3 c2 = rot(wp, octaveMat2);
	float3 c3 = rot(wp, octaveMat3);

	surf += usnoise(wp * surfaceScale * 1.000) * surfaceMagnitude;
	surf += usnoise(wp * surfaceScale * 4.130) * surfaceMagnitude / 3.96;
	surf += usnoise(wp * surfaceScale * 7.980) * surfaceMagnitude / 8.11;
	surf += usnoise(wp * surfaceScale * 1.960) * surfaceMagnitude / 2.13;
	surf += usnoise(wp * surfaceScale * 16.15) * surfaceMagnitude / 15.96;
	surf += usnoise(c0 * surfaceScale * 64.13) * surfaceMagnitude / 63.99;
	surf += usnoise(c1 * surfaceScale * 32.11) * surfaceMagnitude / 31.97;
	surf += usnoise(c2 * surfaceScale * 128.15) * surfaceMagnitude / 127.95;
	surf += usnoise(c3 * surfaceScale * 256.13) * surfaceMagnitude / 255.55;

	return surf;
}

float density(in float3 p)
{

	float d = -surface(p);

	float cube = sdRoundBox(p, float3(15, 15, 10), 2.0);
	float torus = sdTorus(p, float2(50, 5));
	float cyl = sdCappedCylinder(p, 25, 25);

	float a = smin(d, cube, 10).x;
	float b = smin(a, torus, 10).x;
	float c = smin(b, cyl, 10).x;

	return c;

}

float3 calcNormal(in float3 p)
{
	const float h = derivativeStep; // 0.0001
	const float2 k = float2(1, -1);
	return normalize(
		k.xyy * density(p + k.xyy * h) +
		k.yyx * density(p + k.yyx * h) +
		k.yxy * density(p + k.yxy * h) +
		k.xxx * density(p + k.xxx * h));
}

// Slightly more expensive but arguably better
float3 calcNormal2(float3 p) {
	return normalize(float3(
		density(float3(p.x + derivativeStep, p.y, p.z)) - density(float3(p.x - derivativeStep, p.y, p.z)),
		density(float3(p.x, p.y + derivativeStep, p.z)) - density(float3(p.x, p.y - derivativeStep, p.z)),
		density(float3(p.x, p.y, p.z + derivativeStep)) - density(float3(p.x, p.y, p.z - derivativeStep))
	));
}

[numthreads(8,8,1)]
void CSGenerator(uint3 id : SV_DispatchThreadID)
{
	uint index = getVolumeIndex(id);

	// Polygonized chunks are smaller than volume field
	uint3 isoAdjustedSize = isoSize - uint3(2, 2, 2);

	float3 pos = float3(id) + float3(isoAdjustedSize) * chunkOffset;
	float3 noisePos = (pos + noiseOffset) * noiseScale;

	float d = density(noisePos);
	float3 n = calcNormal(noisePos);

	isoDists[index] = d;
	isoNormals[index] = n;
}

[numthreads(8, 8, 1)]
void CSSurfaceGenerator(uint3 id : SV_DispatchThreadID)
{

	// Polygonized chunks are smaller than volume field
	uint3 isoAdjustedSize = isoSize - uint3(2, 2, 2);

	uint step = lodSize / lodRes;

	// Offset heightmap by half its width (because player is in center)
	float halfSize = lodSize / 2;
	float3 lodCenterOffset = float3(halfSize, 0, halfSize);

	// Every id should be STEP units apart (the resolution of the heightmap)
	float3 pos = float3(id.x, 0, id.y) * step + float3(isoAdjustedSize) * chunkOffset * isoScale;
	float3 noisePos = (pos + noiseOffset) * noiseScale;
	float3 offsetPos = (noisePos - lodCenterOffset);

	int idx = id.x + lodRes * id.y;

	isoDists[idx] = surface(offsetPos / isoScale) / (surfaceMagnitude / isoScale);
}
